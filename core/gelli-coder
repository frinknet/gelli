#!/usr/bin/env sh
set -e

# USAGE: gelli coder - Run an iteration of the coder AI
#
# gelli coder [model] [loras...] [-- prompt] - Run model inference with specified prompt and optional LoRAs
#
#   MODEL defaults to $GELLI_MODEL or ol:qwen2.5-Coder:0.5b-Instruct
#   LORAS defaults to $GELLI_LORAS (space separated)
#
#   Examples:
#
#     gelli coder ol:qwen3:0.6b -- "Review the code base"
#     cat file  |  gelli prompt ol:qwen2.5-Coder:0.5b-Instruct -- "can you do something with this"

CTX_SIZE=${GELLI_CTX_SIZE:-0}
BATCH_SIZE=${GELLI_BATCH_SIZE:-512}
OUTPUT_SIZE=${GELLI_OUTPUT_SIZE:-999999}

PORT=${GELLI_PORT:-7771}
MODEL=""
LORAS=""
FLAGS="$GELLI_LLAMA_FLAGS"
PROMPT=""
BRANCH="${GELLI_BRANCH:-gelli-coder}"
TOOLS=""

API=${GELLI_API_URL:-http://localhost:$PORT}
KEY=${GELLI_API_KEY:-GELLI}
MAX=${GELLI_MAY_CALLS:-25}

# Color codes
C_THINK="\e[33m"    # yellow
C_USER="\e[36m"     # cyan
C_ASSIST="\e[32m"   # green
C_TOOL="\e[35m"     # magenta
C_RESET="\e[0m"

cleanup() {
    cd /work

    [ -n "$SERVER_PID" ] && kill "$SERVER_PID" 2>/dev/null || true

    wait "$SERVER_PID" 2>/dev/null || true

    [ -d "/tmp/$BRANCH" ] && git worktree remove --force "/tmp/$BRANCH" 2>/dev/null || true
}
trap cleanup EXIT SIGTERM SIGINT

call-ai() {
  curl -sN "$API/v1/chat/completions" \
    -H "Authorization: Bearer $KEY" \
    -H "Content-Type: application/json" \
    -d "$(jq -c -n \
      --arg m "$MODEL" \
      --argjson msgs "$1" \
      --argjson tools "$TOOLS" \
      '{model:$m,messages:msgs,tools:tools,tool_choice:"auto",stream:true}')"
}

call-fn() {
  [ -f "/tools/$1" ] && exec "/tools/$1" "$2"
  [ "$1" = "date" ] && exec date

  echo "Error: unknown tool '$1'"
}

list-fn() {
  grep '^# DEF: ' /tools/* | sed 's/^.*DEF: //' | jq -R 'fromjson? | select(.)' | jq -sc '.'
}

work-dir() {
  local dir="/tmp/$BRANCH"

  git worktree prune 2>/dev/null || true
  git worktree add --force "$dir"
  cd "$dir"

  # Try to switch, create if doesn't exist
  git switch "$BRANCH" 2>/dev/null || git switch -c "$BRANCH"
}

while [ $# -gt 0 ]; do
  case $1 in
    --)
      shift

      if [ -z "$PROMPT" ]; then
        PROMPT="$*"
      else
        PROMPT="$PROMPT\n\n$*"
      fi

      break
      ;;
    *)
      if [ -z "$MODEL" ]; then
        MODEL="$1"
      else
        LORAS="$LORAS $1"
      fi
      ;;
  esac

  shift
done

if [ -z "$MODEL" ]; then
  MODEL=${GELLI_MODEL:-$GELLI_DEFAULT}
  LORAS=${GELLI_LORAS:-}
fi

if [ -z "$PROMPT" ]; then
  echo "Missing prompt..."
  exit 1
fi

MODEL=$(gelli-models download $MODEL)
LORAS=$(gelli-loras download $LORAS)
TOOLS=$(list-fn)

if [ -n "$LORAS" ]; then
  for f in $LORAS; do FLAGS="$FLAGS --lora /loras/$f.gguf"; done
fi

if [ -z "$GELLI_API_URL" ]; then
  gelli-serve $MODEL $LORAS > /dev/null 2>&1 &

  SERVER_PID=$!

  until curl -sf "$API/health" > /dev/null; do
    sleep 0.2
  done
fi

work-dir

# Initialize chat history
messages='[
  {"role":"system","content":"'"${GELLI_SYSTEM_PROMPT:-You are a coding assistant with access to several tools. Use these tools to fulfill the users request. If you don\'t sse the tools tell the user.}"'"},
  {"role":"user","content":"'"$PROMPT"'"}
]'

echo "$TOOLS"

for iter in $(seq 1 "$MAX"); do
  echo "=== $iter / $MAX ==="

  while IFS= read -r line; do
    [ -z "$line" ] && continue

    delta=$(echo "$line" | jq -c '.choices[0].delta')

    # Partial assistant content with think tag replacement
    if content=$(echo "$delta" | jq -r '.content // empty'); [ -n "$content" ]; then
      # Replace thinking tags with color codes
      content="${content/<think>/${C_THINK}}"
      content="${content/<\/think>/${C_ASSIST}}"

      printf "${C_ASSIST}%s${C_RESET}" "$content"
    fi


    # Extract and validate fn_args
    call=$(echo "$delta" | jq -c '.tool_calls[0] // empty')

    if [ -n "$call" ]; then
      fn_name=$(echo "$call" | jq -r '.function.name // empty')
      fn_args=$(echo "$call" | jq -c '.function.arguments // empty')

      # Only proceed if we have valid data
      if [ -n "$fn_name" ]; then
        printf "${C_TOOL}%s(%s)${C_RESET}" "$fn_name" "${fn_args}"

        result=$(call-fn "$fn_name" "${fn_args}")

        printf "→ ${C_THINK}%s${C_RESET}\n\n" "$result"

        # Build messages with proper JSON validation
        call_msg=$(jq -nc --arg name "$fn_name" --argjson args "${fn_args:-'{}'}" '{role:"assistant",tool_calls:[{function:{name:$name,arguments:$args}}]}')
        result_msg=$(jq -nc --arg name "$fn_name" --arg res "$result" '{role:"tool",name:$name,content:$res}')
        messages=$(jq -nc --argjson m "$messages" --argjson c "$call_msg" --argjson r "$result_msg" '$m + [$c,$r]')
      fi
    fi

    # Check for completion
    if [ -n "$(echo "$line" | jq -e '.choices[0].finish_reason')" ]; then
      printf "\n"

      break 2  # Exit both loops
    fi
  done < <(call-ai "$messages")
done

echo "⚠️  Reached max iterations ($MAX) without final response." >&2
exit 1
