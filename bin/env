#!/usr/bin/env sh

error() {
  echo "Error: $@" >&2

  exit 1
}

safety() {
  local dir=$(echo "$PWD/./${1#$PWD}" | awk -F/ '
    {
      n = split($0, a, "/")
      out = ""

      for(i=1;i<=n;i++){
  if(a[i]=="."||a[i]=="") continue
  else if(a[i]=="..") sub("/[^/]+$", "", out)
  else out=out"/"a[i]
      }

      print out ? out : "/"
    }
  ')

  echo ".${dir#$PWD}"
}

yamlparse() {
    sed '1,/^---$/d' "$1" | yq '(.. | select(tag == "!!str")) |= envsubst' -o=json -
}

jsonparse() {
  json=$(cat)

  for key in $(echo "$json" | jq -r 'keys[]'); do
    value=$(echo "$json" | jq -r ".\"$key\" // empty")

    case "$key" in
      tools|agents|loras) [ -n "$value" ] && eval "$key=\$(echo \"\$value\" | jq -r '.[]')";;
      dir|file) [ -n "$value" ] && eval "$key=\$(safety \"\$value\")";;
      *) eval "$key=\"\$value\""
    esac
  done
}

tools() {
  for tool in "$@"; do
    eval "tool-$tool" 2>/dev/null | jq -Rsc 'fromjson? | select(.) | {"type":"function","function":.}'
  done | jq -sc '.'
}

agents() {
  for agent in "$@"; do
    eval "agent-$agent" 2>/dev/null | jq -Rsc 'fromjson? | select(.) | {
      type: "function",
      function: {
        name: (.name + "_agent"),
        description: .description,
        parameters: {
          type: "object",
          properties: {
            instruct: {
              type: "string",
              description: "Include instructions for this agent"
            },
            context: {
              type: "string",
              description: "Include context for this agent"
            }
          },
          required: ["instruct"]
        }
      }
    }'
  done | jq -sc '.'
}

tooling() {
  if [ -t 0 ]; then
    yamlparse $1

    exit
  fi

  jsonparse
}

dispatch() {
  tooling "$1"

  echo "${context:-Begin}" | exec eval "$BIN-dispatch" "$1" "$instruct"
}

prefix() {
  for file in "$RUN/$1"/*; do
    [ -f "$file" ] || continue
    alias "$2-$(basename "$file")"="$file"
  done
  for file in "$USR/$1"/*; do
    [ -f "$file" ] || continue
    alias "$2-$(basename "$file")"="$file"
  done
}

cleanup() {
  echo CLEANUP $SCRIPT
  cd /work

  [ -n "$SERVER_PID" ] && kill "$SERVER_PID" 2>/dev/null || true

  wait "$SERVER_PID" 2>/dev/null || true

  [ -d "/tmp/$BRANCH" ] && git worktree remove --force "/tmp/$BRANCH" 2>/dev/null || true
}
trap cleanup EXIT SIGTERM SIGINT

branch() {
  echo RUNNING $SERVER_PID
  [ -d ".git" ] || return

  export BRANCH="$1"
  local dir="/tmp/$BRANCH"

  git config --global --add safe.directory "$PWD" &> /dev/null

  git worktree prune &> /dev/null
  git worktree add --force "$dir" &> /dev/null
  cd "$dir"

  # Try to switch, create if doesn't exist
  git switch "$BRANCH" &> /dev/null || git switch -c "$BRANCH" &> /dev/null
}

SCRIPT=
BRANCH=

[ -z "$ENV" ] && export ENV="$(realpath "$0" 2>/dev/null || echo "$ENV")"
[ -z "$RUN" ] && export RUN="${ENV%/bin/env}"
[ -z "$BIN" ] && export BIN="${RUN##*/}"
[ -z "$USR" ] && export USR="$PWD/.$BIN"

export PS1="\n\[\e[1;91m\]  \$PWD \[\e[38;5;52m\]\$\[\e[0m\] \[\e]12;#999900\007\]\[\e]12;#999900\007\]\[\e[3 q\]"

prefix bin "$BIN"
prefix tools tool
prefix agents agent

case "$1" in
"sh --agent")
  shift
  dispatch "$1"
  ;;
"sh --tool")
  shift
  tooling "$1"
  cmd="$1"
  shift
  set -- "$@"
  source "$cmd"
  ;;
"sh")
  shift
  cmd="$1"
  shift
  set -- "$@"
  source "$cmd"
  ;;
esac
