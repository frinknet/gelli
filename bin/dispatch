#!/bin/env sh

set -eo pipefail

# USAGE: gelli dispatch - Dispatch an agent with a prompt
#
# gelli dispatch [agent] [task]
#
# Use `gelli agents` to manage agents

AGENT="$1"

shift || true

INSTRUCT="$@"
CONTEXT="$INSTRUCT"

[ -t 0 ] || CONTEXT=$(cat)

if alias "agent-$AGENT" &> /dev/null; then
  AGENT=$(aliasparse "$AGENT")
fi

if ! [ -f "$AGENT" ]; then  
  error "agent not found"
fi

jsonparse < <(yamlparse "$AGENT")

SYSTEM="# Identity\n${prompt}\n\n# Query\n$INSTRUCT\n\n# Instruction\n Use tools to immediately answer the query."
BRANCH="$BIN-$AGENT"
PORT=${GELLI_PORT:-7771}
MODEL="${model}"
LORAS="${lroas}"
TEMP="${temp}"
FLAGS="$GELLI_LLAMA_FLAGS"
BRANCH="${GELLI_BRANCH:-$BIN-${AGENT##*/}}"
TOOLS=""

API=${GELLI_API_URL:-http://localhost:$PORT}
KEY=${GELLI_API_KEY:-GELLI}
MAX=${GELLI_MAX_CALLS:-25}

CNNTX_SIZE=${GELLI_CTX_SIZE:-0}
BATCH_IZE=${GELLI_BATCH_SIZE:-512}
OUTPUT_SIZE=${GELLI_OUTPUT_SIZE:-999999}

# Color codes
C_THINK="\e[33m"    # yellow
C_USER="\e[36m"     # cyan
C_ASSIST="\e[32m"   # green
C_TOOL="\e[35m"     # magenta
C_RESET="\e[0m"

call-ai() {
  local post=$(jq -c -n \
    --arg model "$MODEL" \
    --argjson messages "${1:-"{}"}" \
    --argjson tools "$TOOLS" \
    '{model:$model,messages:$messages,tools:$tools,tool_choice:"auto",stream:true}')

  echo curl -sN "$API/v1/chat/completions" \
    -H "Authorization: Bearer $KEY" \
    -H "Content-Type: application/json"
  curl -sN "$API/v1/chat/completions" \
    -H "Authorization: Bearer $KEY" \
    -H "Content-Type: application/json" \
    -d "$post"
}

call-fn() {
  local tool

  case "$1" in
  *_agent) tool="agent-${1%_agent}";;
  *) tool="tool-$1";;
  esac

  if alias "$tool" &> /dev/null; then
    printf "$2" | eval "$tool"

    [ "$?" = 0 ] || echo "Error: failed $1($2)"
  else
    echo "Error: unknown tool - $1($2)"
  fi
}

list-fn() {
  {
    tools $tools
    agents $agents
  } | jq -sc 'add'
}

if [ -z "$MODEL" ]; then
  MODEL=${GELLI_MODEL:-$GELLI_DEFAULT}
  LORAS=${GELLI_LORAS:-}
fi

TOOLS=$(list-fn)

if [ -n "$LORAS" ]; then
  for f in $LORAS; do FLAGS="$FLAGS --lora /loras/$f.gguf"; done
fi

[ -z "$GELLI_API_URL" ] && gelli-serve "$MODEL" "$LORAS" &> /dev/null &

SERVER_PID=$!

branch $BRANCH

until curl -sf "$API/health" &> /dev/null; do
  sleep 2
done

# Initialize chat history
messages='[
  {"role":"system","content":"'"$SYSTEM"'"},
  {"role":"user","content":"'"$CONTEXT"'"}
]'

# Initialize tool calls
tool_calls=""
has_talked=""

for iter in $(seq 1 "$MAX"); do
  echo "$iter dude"
  while IFS= read -r data; do
    [ -z "$data" ] && continue
    [ "$data" = "data: [DONE]" ] && break

    finish=$(echo "${data#data: }" | jq -r '.choices[0].finish_reason // empty')
    delta=$(echo "${data#data: }" | jq -c '.choices[0].delta')


    #TODO: allow interaction

    # Reasoning
    if reasoning=$(echo "$delta" | jq -r '.reasoning_content // empty'); [ -n "$reasoning" ]; then
      printf "${C_THINK}%s${C_RESET}" "$reasoning"

    # Talking
    elif content=$(echo "$delta" | jq -r '.content // empty'); [ -n "$content" ]; then
      [ -z "$has_talked" ] && has_talked=1 && echo -e "\n"

      printf "${C_ASSIST}%s${C_RESET}" "$content"
    fi

    # Buffer tool call arguments
    fn_out=$(echo "$delta" | jq -c '.tool_calls // []')
    fn_len=$(echo "$fn_out" | jq length)

    for i in $(seq 0 $((fn_len - 1))); do
      fn_call=$(echo "$fn_out" | jq -c .[$i])
      fn_slot=$(echo "$fn_call" | jq -r '.index // 0')
      fn_name=$(echo "$fn_call" | jq -r '.function.name // empty')
      fn_args=$(echo "$fn_call" | jq -r '.function.arguments // empty')

      # If function name is here, set the fn_tool
      if [ -n "$fn_name" ]; then
        fn_tool="tool_$(printf '%s' "$fn_name" | tr -c 'a-zA-Z0-9_' '_')_$fn_slot"
        tool_calls="$tool_calls $fn_tool"
      else
        fn_tool=""

        # If the function name isn't here, find the buffer for this index
        for tool in $tool_calls; do
          if [ "${tool##*_}" = "$fn_slot" ]; then
            fn_tool="$tool"

            break
          fi
        done
      fi

      # Always append to the correct buffer, if we found it
      if [ -n "$fn_tool" ] && [ -n "$fn_args" ]; then
        eval "$fn_tool=\"\${$fn_tool:-}\$fn_args\""
      fi
    done

    # On finish_reason:tool_calls, process all buffered tool calls
    if [ "$finish" = "tool_calls" ]; then
      for fn_tool in $tool_calls; do
        fn_call="${fn_tool#tool_}"
        fn_slot="${fn_call##*_}"
        fn_name="${fn_call%_*}"
        fn_args=$(eval echo \"\$$fn_tool\" | jq -c '.')

        printf "\n\n ${C_TOOL}â†’ %s(%s)${C_RESET}\n" "$fn_name" "$fn_args"

        fn_back=$(call-fn "$fn_name" "$fn_args")
        ms_call=$(jq -nc --arg fn_slot "$fn_slot"  --arg fn_name "$fn_name" --arg fn_args "${fn_args:-"{}"}" '{role:"assistant",tool_calls:[{index:$fn_slot,type:"function",function:{name:$fn_name,arguments:$fn_args}}]}')
        ms_back=$(jq -nc --arg fn_back "$fn_back" '{role:"tool",content:$fn_back}')
        messages=$(jq -nc --argjson messages "$messages" --argjson ms_call "$ms_call" --argjson ms_back "$ms_back" '$messages + [$ms_call,$ms_back]')

        unset "$fn_tool"
      done

#echo "$messages"
      # Reset for next batch
      tool_calls=""
      has_talked=""

    elif [ "$finish" = "stop" ]; then
      echo
      exit 0
    elif [ -n "$finish" ]; then
      printf "\n\nEXIT %s\n" "$data" 
      exit 0
    fi
  done < <(echo)

  call-ai "$messages"

  echo
done

exit 1
